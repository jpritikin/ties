\documentclass[12pt]{article}
\usepackage{fixltx2e}
\usepackage[margin=1in]{geometry}
\usepackage{graphicx}
\usepackage{authblk}
\setlength{\parindent}{0cm}
\setlength{\parskip}{1ex}

<<echo=FALSE, results='hide', warning=FALSE, cache=FALSE>>=
#options(error = browser)
library(knitr)
#knit("cms-calibrate.Rnw", tangle=TRUE)  # to extract only the R chunks
opts_knit$set(error=TRUE)
opts_chunk$set(echo=FALSE, cache=FALSE)
loadlib <- function () {
  library(rpf)
  library(OpenMx)
  library(xtable)
  library(ctsem)
  source("lab.R")
}
suppressPackageStartupMessages(loadlib())
@

\title{Continuous Time Factor Analysis of the 2015~Meditation Class}
\date{\today}
\author[1]{Joshua N.~Pritikin}
\author[2]{Charles C.~Driver}
\affil[1]{University of Virginia}
\affil[2]{Max Planck Institute for Human Development, Berlin}

\begin{document}
\maketitle


<<>>=
{
  wd <- setwd("..")
  source("measures.R")
  source("cms-score.R")
  setwd(wd)
}

SexItem <- c("Male","Female")

RelaItem = c('Single',
             'In a long-term relationship (i.e. together more than a year)',
             'Other')
RelaItemShort = c('Single',
                  'Together',
                  'Other')
numWaves <- 9

# declare global variables
born <- NULL
sex <- NULL
rel <- NULL
UnfilteredID <- NULL
labTime <- NULL
labTA <- NULL
lifeExperience <- c('msMet', 'msShared', 'msTeach','msTrainTeach')
tformat <- "%m/%d/%Y %H:%M:%S"
reftime <- strptime("01/07/2015 12:00:00", tformat)
labGrid <- buildLabTable(reftime)
manifestNames <- NULL
TDpredNames<-'lab'
n.TDpred <- length(TDpredNames)

long <- NULL

for (wave in 1:numWaves) {
  raw <- read.csv(sprintf("wave%d-anon.csv", wave), stringsAsFactors=FALSE)
  offset <- 3+ifelse(wave==1, 3, 0)
  if (wave == 1) {
    born <- raw[[3]]
    sex <- factor(raw[[4]], levels=SexItem, labels=tolower(SexItem))
    rel <- factor(raw[[5]], levels=RelaItem, labels=tolower(RelaItemShort))
    UnfilteredID <- raw$id
    labTime <- raw$labTime
    labTA <- raw$labTA
  }
  envMastery <- score.ryff.envMastery14(raw[offset:(offset + 14 - 1)])
  offset <- offset + 14 + ifelse(wave==1, 5, 0)
  cmsCol <- raw[,offset:(offset+24-1)]
  cmsCol <- cbind(NA,NA,NA,NA,NA,cmsCol)
  cms <- prep.cms201410(cmsCol)
  cms[['instrument']] <- NULL
  cms <- cms.testlets(cms)
  for (del in c(
    'msNotion', 'msAny', 'msChildhood', 'msEvery', 'wantLearn', 'skipInt',
    'pctSuccess', 'msEmo', 'msFast1', 'msIdAfraid', 'msIdAfraidLearn',
                'msFastEffort','msFastEffortLife', lifeExperience)) {
    cms[[del]] <- NULL
  }
#  if (is.null(itemLev)) itemLev <- unlist(lapply(cms, function(col) length(levels(col))))
  cms <- sapply(cms, unclass)
  cms <- cbind(cms, envMastery=envMastery)
  if (is.null(manifestNames)) manifestNames <- colnames(cms)
  mask <- apply(cms, 1, function (r) any(!is.na(r)))
  relweek <- as.numeric((strptime(raw$EndDate, "%m/%d/%Y %H:%M:%S") - reftime))/7
  long <- rbind(long, data.frame(
    id=raw$id[mask], time=relweek[mask], cms[mask,], lab=0
  ))
}

long<-long[!is.na(long[,'time']),] #remove rows with no time observation


if (FALSE) {  # add labs as separate rows at the correct time
  labRow <- NULL
  for (row in which(!is.na(labTime))) {
    potentialLabs <- data.frame(
      id=UnfilteredID[row], time=as.numeric(labGrid[labTime[row],])/7)
    tpoints <- long[long$id==UnfilteredID[row],'time']
    if (length(tpoints) < 2) next
    rtp <- range(tpoints)
    mask <- rtp[1] < potentialLabs$time & potentialLabs$time < rtp[2]
    labRow <- rbind(labRow, potentialLabs[mask,])
  }
  for (col in colnames(cms)) labRow[[col]] <- NA
  labRow[['lab']] <- 1
  long <- rbind(long, labRow)
}
if (TRUE) {   # add labs at the wrong time to speed up estimation
  labRow <- NULL
  for (row in which(!is.na(labTime))) {
    potentialLabs <- data.frame(
      id=UnfilteredID[row], time=as.numeric(labGrid[labTime[row],])/7)
    tpoints <- long[long$id==UnfilteredID[row],'time']
    rtp <- range(tpoints)
    potentialLabs <- potentialLabs[rtp[1] < potentialLabs$time & potentialLabs$time < rtp[2],]
    active <- findInterval(potentialLabs$time, tpoints)
    long[which(long$id==UnfilteredID[row])[unique(active)],'lab'] <- 1
  }
}

latents <- c("labeffect", "training", "ties", "envMastery")

free_path <- function(lambda, from, to) {
  lambda[from, to] <- apply(expand.grid(from, to), 1, paste0, collapse="_to_")
  lambda
}

# a plausible factor structure
lambda <- matrix("0", nrow=length(manifestNames), ncol=length(latents),
                 dimnames=list(manifestNames, latents))
lambda['envMastery', 'envMastery'] <- 1

lambda['freqCause', 'training'] <- 1
lambda <- free_path(lambda, paste0(lifeExperience, "Num"), 'training')
lambda <- free_path(lambda, c('msAfraid', 'msIdentity', 'msEffort'), 'training')

lambda['maxDuration', 'ties'] <- 1
lambda <- free_path(lambda, c('msFast', 'msLife', 'msPreoccu'), 'ties')
lambda <- free_path(lambda, c('maxDurationOut', 'successCat'), 'ties')

lambda <- free_path(lambda, c('msTimeAlloc', 'msYearn', 'msEnv', 'msAllow', 'msTaught'),
                    c('training', 'ties'))

longUniqueIds <- unique(long[,'id'])
numUniqueObs <- sapply(1:length(longUniqueIds),
                       function(x) sum(long[,'id'] == longUniqueIds[x]))
container <- mxModel(model="ctraw")
uniqueTpoints <- sort(unique(numUniqueObs))
partition <- cut(uniqueTpoints, 3)
for (px in levels(partition)) {
  Tpoints <- uniqueTpoints[partition == px]
  long1 <- subset(long, id %in% longUniqueIds[which(numUniqueObs %in% Tpoints)])
  wide <- ctLongToWide(long1, id="id", time="time",
                       manifestNames=manifestNames, TDpredNames=TDpredNames)
  wide <- ctIntervalise(wide, max(Tpoints), n.manifest=length(manifestNames), n.TDpred=n.TDpred,
                        manifestNames=manifestNames, TDpredNames = TDpredNames)

  if (FALSE) {
    #plot means
    for(i in 1:length(manifestNames)){
      plot(0:(numWaves-1),apply(wide[,paste0(manifestNames[i],'_T',0:(numWaves-1))],2,mean,na.rm=T),type='b',main=paste0('mean ', manifestNames[i]))
    }
  }
  
  model <- ctModel(
    n.manifest=length(manifestNames), n.latent=length(latents),
    Tpoints=max(Tpoints), n.TDpred=n.TDpred,
    LAMBDA=lambda, manifestNames=manifestNames, latentNames=latents, TDpredNames=TDpredNames,
    T0TDPREDCOV=matrix(0, nrow=length(latents), ncol=(max(Tpoints)-1)*n.TDpred),
     TRAITTDPREDCOV=matrix(0, nrow=length(latents), ncol=(max(Tpoints)-1)*n.TDpred), #I don't think we know this is 0 - unless the lab or control condition was randomly assigned?
    MANIFESTTRAITVAR = "auto" #to begin, I would use MANIFESTTRAITVAR so that all between person variance is removed (people can be consistently high / low on some manifest variables of a process and not others) - we can work on the between person structure more adequately once we understand the dynamic structure somewhat. 
  )
  
  model$DIFFUSION[,match('labeffect',latents)] <- 0
  model$T0VAR[,match('labeffect',latents)] <- 0
  model$CINT[,] <- 0
  model$MANIFESTMEANS <- matrix(paste0('mean_',manifestNames),ncol=1)
  model$T0MEANS[,] <- 0
  model$TDPREDEFFECT[-which(latents %in% 'labeffect'),] <- 0
  model$DRIFT[match('labeffect',latents),match('labeffect',latents)] <- 0
  # We know that changes in latent processes do not cause labs
  model$DRIFT[match('labeffect',latents),] <- 0
  model$TDPREDVAR <- diag(0.1,max(Tpoints)-1)
 model$DRIFT[!diag(length(latents))] <- 0
  
  m1 <- ctFit(wide, model, nofit=TRUE, meanIntervals=T,stationary=c('T0VAR','T0MEANS'))
  m1 <- mxRename(m1, sprintf("group%02d_%02d", min(Tpoints), max(Tpoints)))
  container <- mxModel(container, m1)
}

container <- mxModel(container,
                     mxFitFunctionMultigroup(names(container$submodels)))
container <- omxAssignFirstParameters(container)

container<- OpenMx::mxOption(container, 'Always Checkpoint', 'Yes')
container<- OpenMx::mxOption(container, 'Checkpoint Units', 'iterations')
container<- OpenMx::mxOption(container, 'Checkpoint Count', 1)    
container <- mxModel(container,
                     mxComputeGradientDescent(nudgeZeroStarts=FALSE, verbose=2))
fit <- mxRun(container)

# fit <- ctFit(wide, model, retryattempts=0, verbose=2, meanIntervals=T,
#              stationary=c('T0VAR','T0MEANS'), plotOptimization=T)



if (0) {
  
  ####Without lab influence but modelling trend instead
  wide <- ctLongToWide(long, id="id", time="time",
                       manifestNames=manifestNames)
  wide <- ctIntervalise(wide, numWaves, length(manifestNames), n.TDpred=0,manifestNames=manifestNames)
  latents <- c("trend", "training", "ties", "envMastery")
  n.TDpred <- 0
  
  free_path <- function(lambda, from, to) {
    lambda[from, to] <- apply(expand.grid(from, to), 1, paste0, collapse="_to_")
    lambda
  }
  
  # a plausible factor structure
  lambda <- matrix("0", nrow=length(manifestNames), ncol=length(latents),
                   dimnames=list(manifestNames, latents))
  lambda['envMastery', 'envMastery'] <- 1
  
  lambda['freqCause', 'training'] <- 1
  lambda <- free_path(lambda, paste0(lifeExperience, "Num"), 'training')
  lambda <- free_path(lambda, c('msAfraid', 'msIdentity', 'msEffort'), 'training')
  
  lambda['maxDuration', 'ties'] <- 1
  lambda <- free_path(lambda, c('msFast', 'msLife', 'msPreoccu'), 'ties')
  lambda <- free_path(lambda, c('maxDurationOut', 'successCat'), 'ties')
  
  lambda <- free_path(lambda, c('msTimeAlloc', 'msYearn', 'msEnv', 'msAllow', 'msTaught'),
                      c('training', 'ties'))
  
  model <- ctModel(
    n.manifest=length(manifestNames), n.latent=length(latents), Tpoints=numWaves, n.TDpred=n.TDpred,
    LAMBDA=lambda, manifestNames=manifestNames, latentNames=latents, 
    MANIFESTTRAITVAR = "auto" #to begin, I would use MANIFESTTRAITVAR so that all between person variance is removed (people can be consistently high / low on some manifest variables of a process and not others) - we can work on the between person structure more adequately once we understand the dynamic structure somewhat. 
  )
  
  # model$TRAITVAR[,match('lab',latents)] <- 0
  model$DIFFUSION[,match('trend',latents)] <- 0
  model$T0VAR[,match('trend',latents)] <- 0
  model$CINT[match('trend',latents),] <- 1
  model$T0MEANS[match('trend',latents),] <- 0
  model$DRIFT[match('trend',latents),match('trend',latents)] <- 0
  # We think that changes in latent processes do not cause trends
  model$DRIFT[match('trend',latents),] <- 0
  
  
  fit <- ctFit(wide, model, retryattempts=10, verbose=2, stationary=c('T0MEANS', 'T0VAR'),meanIntervals=T)
}

@

\end{document}
