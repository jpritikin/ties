\documentclass[12pt]{article}
\usepackage[margin=.5in]{geometry}
\usepackage{pdfpages}
\setlength{\parindent}{0cm}
\setlength{\parskip}{1ex}

<<echo=FALSE, results='hide', warning=FALSE, cache=FALSE>>=
#options(error = browser)
library(knitr)
#knit("cms-calibrate.Rnw", tangle=TRUE)  # to extract only the R chunks
opts_knit$set(error=TRUE)
opts_chunk$set(echo=FALSE, cache=FALSE)
loadlib <- function () {
library(rpf)
library(OpenMx)
library(ggplot2)
library(reshape2)
library(plyr)
library(grid)
library(gridExtra)
library(xtable)
}
suppressPackageStartupMessages(loadlib())
options(digits=2, scipen=1)
plot.width=3

assertColumnExist <- function(col) {
  missing <- col[is.na(match(col, colnames(espt)))]
  if (length(missing)) stop(paste("Columns missing:", omxQuotes(missing)))
}

itemMapText <- geom_text(size=4, position=position_jitter(h=.25))
@

\title{Calibration of item models for the Complete Mental Silence Disposition Scale}
\date{\today}
\author{Joshua N.~Pritikin\\ University of Virginia}

\begin{document}
\maketitle

\section{Data Sources}

The CMS calibration sample is composed of a number of different datasets.

<<results='asis'>>=
source('irtplot.R')
source("cms-score-lib.R")

load("espt.rda")
espt <- cms.testlets(espt)

src <- ddply(espt, ~wave, function(slice) c(types=length(unique(slice$instrument))))

if (any(src$types != 1)) {
  stop("There should be no more than 1 instrument version per wave.")
}

src <- ddply(espt, ~wave, function(slice) c(instrument=unique(slice$instrument), count=nrow(slice),
                                            start=min(slice$start), end=max(slice$end)))
src <- src[order(src$instrument, src$end, src$start),]
print(xtable(src), include.rownames=FALSE)
@

A large proportion of data is missing, but the maximum N=\Sexpr{sum(as.numeric(src$count))}.

\section{Barrier}

The \emph{barrier} factor is intended to non-judgmentally assess the participant's
self-reported inability to experience complete mental silence.
The items must make sense on a short time horizon and
should also be amenable to long-term barriers.

<<>>=
fitBarrer <- function(ba.data, minItems) {
  barrier.items <- colnames(ba.data)
  
  assertColumnExist(barrier.items)
  
  spec <- lapply(barrier.items, function(nm) {
    lev <- length(levels(ba.data[[ nm ]]))
    rpf.grm(outcomes=lev, factors=3)
  })
  
  maxParam <- max(sapply(spec, rpf.numParam))
  factors <- c('barrier', 'emo', 'struct')
  ip.mat <- mxMatrix(name="item", nrow=maxParam, ncol=length(spec), free=FALSE,
                     dimnames=list(c(factors,
                                     paste('b', 4:maxParam, sep="")), barrier.items))
  ip.mat$values['barrier',] <- 1
  ip.mat$values['emo',intersect(c('wantLearn', "msAfraid", "msIdentity","msEmo"),barrier.items)] <- 1
  ip.mat$values['struct',intersect(c("msFast", "msFast1", "msEffort", "msLife"), barrier.items)] <- 1
  ip.mat$values[4:7,] <- mxSimplify2Array(lapply(spec, function(s) seq(1,.1,length.out = s$outcomes-1)))
  ip.mat$free[,] <- !is.na(ip.mat$values[,]) & ip.mat$values[,] != 0
  
  ba <- mxModel(model="barrier", ip.mat,
                mxData(observed=ba.data, type="raw"),
                mxExpectationBA81(spec, qwidth=5, qpoints=39),
                mxFitFunctionML(),
                mxComputeSequence(steps=list(
                  mxComputeEM('expectation', 'scores', mxComputeNewtonRaphson()),
                  mxComputeOnce('fitfunction', 'information', "meat"),
                  mxComputeStandardError(),
                  mxComputeHessianQuality())
                ))
  got <- mxRun(ba, silent=TRUE)
  got
}

bitem <- c("msAfraid", "msIdentity", "msFast", "msEffort", "msLife", "msEmo")
notSure <- apply(espt[,bitem] == "not sure", 1, all)
notSure <- !is.na(notSure) & notSure
ba.data <- espt[!notSure, c("msAfraid", "msIdentity", "msFast1", "msEffort", "msLife", "msEmo")]

# "msDescarte" == worst S fit
# "wantLearn" poor discrimination, locally dependent with msEffort (duh) & msEmo
minItems <- 3
ba.est <- fitBarrer(ba.data, minItems)

interactive <- FALSE
if (interactive) {
  ba.est$output$conditionNumber
}
ba.grp <- as.IFAgroup(ba.est)
ba.grp$minItemsPerScore = minItems
ba.grp$score <- EAPscores(ba.grp)

mnf <- multinomialFit(ba.grp)
if (interactive) {
  ba.grp$param
  mnf
}

if (0) {
  mcReps <- 100
  stat <- rep(NA, mcReps)
  for (rx in 1:mcReps) {
    t1 <- ba.grp
    t1$data <- rpf.sample(grp=ba.grp)
    got <- multinomialFit(t1)
    stat[rx] <- got$statistic
  }
  log(sum(stat > mnf$statistic) / mcReps)
}
@ 

For a single factor model, the items were highly locally dependent.
Two subfactors were hypothesized: an emotional subfactor for
\Sexpr{names(which(ba.grp$param['emo',] !=0))}; and a structural subfactor for
\Sexpr{names(which(ba.grp$param['struct',] !=0))}.
A candidate bi-factor model was fit with -2LL=\Sexpr{ba.est$output$fit} and
condition number \Sexpr{ba.est$output$conditionNumber}.
The full-information multinomial fit test was conducted,
$n=\Sexpr{mnf$n}$, $G^2(\Sexpr{mnf$df})=\Sexpr{mnf$statistic}$.
Since the $\chi^2$ distribution is a poor approximation
for such a large table, a $p$-value of about .05
was obtained via Monte-Carlo simulation.

<<fig.height=2>>=
tbl <- sumScoreEAP(ba.grp)
got <- sumScoreEAPTest(ba.grp)
df <- data.frame(score=as.numeric(rownames(tbl)),
            expected=tbl[,'p'] * got$n, observed=got$observed)
df <- melt(df, id="score", variable.name="source", value.name="n")
ggplot(df, aes(x=score, y=n, color=source)) + geom_line()

if (0) {
  ss <- observedSumScore(ba.grp, summary=FALSE)
  mask <- !is.na(ss) & ss==12
  ss12 <- ba.grp$data[mask,]
  which(apply(ss12, 1, function(r) all(r == "not sure")))  # huh?
}
@

<<results='asis'>>=
got <- ChenThissen1997(ba.grp)
print(xtable(got$pval, paste("Log p-value of local dependence between item pairs.")))
@

<<results='asis'>>=
sfit <- SitemFit(ba.grp, omit = 1, qpoints=31, qwidth=5)
tbl <- t(sapply(sfit, function(r) c(n=r$n, df=r$df, stat=r$statistic, pval=r$pval)))
print(xtable(tbl, paste("Sum-score item-wise fit, omitting 1 item.",
                        "For msFast, \\emph{disagree somewhat} was collapsed",
                        "to \\emph{not sure} to improve fit.",
                        "There may be more room for improvement here.")))
@

<<fig.height=2>>=
map1 <- item.map(ba.grp, 1)
ggplot(map1, aes(x=score, y=item, label=outcome)) + itemMapText
@

<<fig.height=3>>=
pl <- lapply(colnames(ba.grp$param), function(item) {
  SSplot(sfit, item)
})
for (px in 1:length(pl)) {
  print(pl[[px]])
}
print(plot.info(ba.grp, width=5, show.total=FALSE, basis=c(1,0,0)))
@

\section{Training}

The \emph{training} factor is intended to assess the self-reported degree
of preparation and expertise a participant has with complete mental silence.
The items probe ability to cause oneself to experience mental silence
and ability to work with others.
To assess experience with others,
items probe both belief in oneself to work with others and
quantitatively how much one has worked with others.

<<results='asis'>>=
print(xtable(table(espt[,c("msAllow","msCause")]),
             paste("The msAllow and msCause items seem to measure practically",
                   "the same thing. Participants are slighly more willing to",
                   "endorse higher outcomes in msAllow compared to msCause.",
                   "I prefer to use msAllow, but msAllow has too much missing",
                   "data at this time.")))
@ 

<<>>=
fitTraining <- function(training.items) {
  assertColumnExist(training.items)
  
  tr.data <- espt[,training.items]
  
  nfactors <- 3
  spec <- lapply(training.items, function(nm) {
    lev <- length(levels(tr.data[[ nm ]]))
    rpf.grm(outcomes=lev, factors=nfactors)
  })
  names(spec) <- training.items
  
  for (item in c('trainSkill', 'trainNum')) {
    spec[item] <- mkspec(espt, item, nfactors)
  }
  numItems <- length(training.items)
  maxParam <- max(sapply(spec, rpf.numParam))
  
  imat <- mxMatrix(name="item", nrow=maxParam, ncol=numItems, free=FALSE,
                     dimnames=list(c('training', 'other', 'self',
                                     paste('p',4:maxParam,sep="")), training.items))
  imat$values[,] <- mxSimplify2Array(lapply(spec, rpf.rparam))
  imat$values[c('other', 'self'),] <- 0
  imat$free[,] <- !is.na(imat$values) & imat$values[,] != 0
  imat$values['training',] <- 1

  imat <- set.nominal.rank(spec, imat, 'trainSkill', 0, .3)
  imat <- set.nominal.rank(spec, imat, 'trainNum', 0, .15)

  selfGroup <- intersect(training.items, c("msYearn", "msEnv", "msAllow"))
  otherGroup <- intersect(training.items, c("trainSkill", "trainNum"))
  imat$values['self',selfGroup] <- 1
  imat$free['self',selfGroup] <- TRUE
  imat$values['other',otherGroup] <- 1
  imat$free['other',otherGroup] <- TRUE
  
  train <- mxModel(model="training", imat,
                   mxData(observed=tr.data, type="raw"),
                   mxExpectationBA81(spec, qpoints=27, qwidth=5),
                   mxFitFunctionML(),
                   mxComputeSequence(steps=list(
                     mxComputeEM('expectation', 'scores', mxComputeNewtonRaphson()),
                     mxComputeOnce('fitfunction', 'information', "meat"),
                     mxComputeStandardError(),
                     mxComputeHessianQuality())
                   ))
  got <- mxRun(train, silent=TRUE)
  got
}

# not specific enough: "msAny", "msEvery"
# c("yearnEnv", "allowCause", "trainSkill", "trainNum")
tr.est <- fitTraining(c("msYearn", "msEnv", "msCause", "trainSkill", "trainNum"))
tr.grp <- as.IFAgroup(tr.est)
tr.grp$minItemsPerScore = 1L

tr.grp$scores <- EAPscores(tr.grp)

mnf <- multinomialFit(omitMostMissing(tr.grp, 1))

if (0) {
  mcReps <- 100
  stat <- rep(NA, mcReps)
  for (rx in 1:mcReps) {
    t1 <- tr.grp
    t1$data <- rpf.sample(grp=tr.grp)
    got <- multinomialFit(t1, omit=1)
    stat[rx] <- got$statistic
  }
  log(sum(stat > mnf$statistic) / mcReps)
}

@

Calibration of the training factor is hindered by the late addition
of the trainNum item.
For a single factor model, the items were highly locally dependent.
Two subfactors were hypothesized: a self subfactor for
\Sexpr{names(which(tr.grp$param['self',] !=0))}; and an other subfactor for
\Sexpr{names(which(tr.grp$param['other',] !=0))}.
A candidate model obtains $-2LL=\Sexpr{tr.est$output$fit}$
with condition number \Sexpr{tr.est$output$conditionNumber}.
The full-information multinomial fit test was conducted,
$n=\Sexpr{mnf$n}$, $G^2(\Sexpr{mnf$df})=\Sexpr{mnf$statistic}$.
Since the $\chi^2$ distribution is a poor approximation
for such a large table, a $p$-value of about 1
was obtained via Monte-Carlo simulation.

<<fig.height=2>>=
tr.grp1 <- omitMostMissing(tr.grp, 1)
tbl <- sumScoreEAP(tr.grp1)
got <- sumScoreEAPTest(tr.grp1)
df <- data.frame(score=as.numeric(rownames(tbl)),
            expected=tbl[,'p'] * got$n, observed=got$observed)
df <- melt(df, id="score", variable.name="source", value.name="n")
ggplot(df, aes(x=score, y=n, color=source)) + geom_line()
@


<<results='asis'>>=
got <- ChenThissen1997(tr.grp)
print(xtable(got$pval, "Log p-value of local dependence between item pairs."))
@ 

<<results='asis'>>=
sfit <- SitemFit(tr.grp, omit = 1)
tbl <- t(sapply(sfit, function(r) c(n=r$n, df=r$df, stat=r$statistic, pval=r$pval)))
print(xtable(tbl, paste("Sum-score item-wise fit, omitting 1 item.")))
@

<<fig.height=2>>=
map1 <- item.map(tr.grp, 1)
ggplot(map1, aes(x=score, y=item, label=outcome)) + itemMapText
@

<<fig.height=3>>=
pl <- lapply(colnames(tr.grp$param), function(item) {
  SSplot(sfit, item)
})
for (px in 1:length(pl)) {
  print(pl[[px]])
}
print(plot.info(tr.grp, width=5, show.total=FALSE, basis=c(1,0,0)))
@

\section{Event}

The \emph{event} factor is intended to assess the self-reported
intensity of experiencing complete mental silence.

<<>>=
fitEvent <- function(event.items, minItems) {
  assertColumnExist(event.items)
  
  spec <- mkspec(espt, event.items)
  numItems <- length(event.items)
  maxParam <- max(sapply(spec, rpf.numParam))
  
  ip.mat <- mxMatrix(name="item", nrow=maxParam, ncol=numItems, free=FALSE,
                     dimnames=list(c("event", paste("p",2:maxParam,sep="")), event.items))
  
  ip.mat <- set.nominal.rank(spec, ip.mat, 'msAny', .51, 1)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'msEvery', .51, 1)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'freqCause', .51, 1)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'successCat', .35, .5)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'maxDuration', .51, 1)
  
  ev.data <- espt[,event.items]
  
  ev <- mxModel(model="event", ip.mat,
                mxData(observed=ev.data, type="raw"),
                mxExpectationBA81(spec),
                mxFitFunctionML(),
                mxComputeSequence(steps=list(
                  mxComputeEM('expectation', 'scores', mxComputeNewtonRaphson()),
                  mxComputeOnce('fitfunction', 'information', "meat"),
                  mxComputeStandardError(),
                  mxComputeHessianQuality())
                ))
  mxRun(ev, silent=TRUE)
}

minItems <- 2L
ev.est <- fitEvent(c("freqCause", "successCat", "maxDuration"), minItems)

ev.grp <- list(spec=ev.est$expectation$ItemSpec,
            param=ev.est$item$values,
            data=espt[,colnames(ev.est$item)],
            minItemsPerScore=minItems,
            free=ev.est$item$free)
ev.grp$scores <- EAPscores(ev.grp)

mnf <- multinomialFit(ev.grp)

if (0) {
  mcReps <- 100
  stat <- rep(NA, mcReps)
  for (rx in 1:mcReps) {
    t1 <- ev.grp
    t1$data <- rpf.sample(grp=ev.grp)
    got <- multinomialFit(t1, omit=1)
    stat[rx] <- got$statistic
  }
  log(sum(stat > mnf$statistic) / mcReps)
}
@ 

A possible model had -2LL=\Sexpr{ev.est$output$fit} and
condition number \Sexpr{ev.est$output$conditionNumber}.
The full-information multinomial fit test was conducted,
$n=\Sexpr{mnf$n}$, $G^2(\Sexpr{mnf$df})=\Sexpr{mnf$statistic}$, $\log(p)=\Sexpr{mnf$pval}$.
To double-check the $p$-value, a Monte-Carlo simulation
was conducted, $\log(p) = -.92$.

<<results='asis'>>=
got <- ChenThissen1997(ev.grp)
print(xtable(got$pval, "Log p-value of local dependence between item pairs."))
@ 

<<fig.height=2>>=
map1 <- item.map(ev.grp, 1)
ggplot(map1, aes(x=score, y=item, label=outcome)) + itemMapText
@

<<fig.height=3>>=
pl <- lapply(colnames(ev.grp$param), function(item) {
  rpf.plot(ev.grp, item, width=plot.width, data.bins=12, basis=c(1), factor=1)
})
for (px in 1:length(pl)) {
  print(pl[[px]])
}
print(plot.info(ev.grp, width=4, show.total=FALSE))
@ 

<<>>=
ba.grp$data <- NULL
tr.grp$data <- NULL
# ev.grp$data <- NULL
save(ba.grp, tr.grp, ev.grp, file="cms-fit.rda")

#items <- t(m2$ItemParam@values)
#rownames(items) <- item.names
#espt[mask, "score"] <- m2@expectation@scores.out[,1]
#espt[mask, "se"] <- m2@expectation@scores.out[,2]

if (0) {
  sc <- m2.est@expectation@scores.out
  for (l in 1:3) {
    mask <- espt$durationCharacter==levels(espt$durationCharacter)[l]
    mask <- !is.na(mask) & mask
    print(paste(l, mean(sc[mask,1]), mean(sc[mask,2])))
  }
}
@

\section{Cross-sectional Relationship}

<<results='asis'>>=
source("cms-score.R")
cms <- cms.score(espt)
miss <- apply(cms, 2, function(c) sum(is.na(c))) / nrow(cms)
miss <- t(100 * miss)
rownames(miss) <- "% missing"
print(xtable(miss, "Percentage of scores missing."))
@ 

<<results='asis'>>=
fl <- rbind(apply(cms, 2, function(c) sum(c==min(c, na.rm=TRUE), na.rm=TRUE)),
            apply(cms, 2, function(c) sum(c==max(c, na.rm=TRUE), na.rm=TRUE)))
fl <- fl * 100 / nrow(cms)
rownames(fl) <- c("floor", "ceiling")
print(xtable(fl, "Percentage of scores at floor and ceiling."))
@ 

<<results='asis'>>=
ctbl <- cor(cms, use="pairwise.complete.obs")
ctbl[upper.tri(ctbl, diag=TRUE)] <- NA
print(xtable(ctbl, "Correlation matrix of factor scores."))
@ 

<<fig.height=3>>=
mask1 <- !is.na(cms[,'barrier']) & !is.na(cms[,'event'])
mask2 <- !is.na(cms[,'training']) & !is.na(cms[,'event'])
grid.arrange(qplot(cms[mask1,'barrier'],  cms[mask1,'event']) + coord_fixed() +
                     labs(x="barrier", y="event") + geom_abline(slope=-1, color="red"),
                   qplot(cms[mask2,'training'], cms[mask2,'event']) + coord_fixed() +
                     labs(x="training", y="event") + geom_abline(slope=1, color="red"), ncol=2)

fit1 <- lm(event ~ ., data=as.data.frame(cms))
#  plot(fit1)

co <- round(coef(fit1),2)
mask3 <- apply(cms, 1, function (r) all(!is.na(r)))
print(qplot(co[1] + co[2] * cms[mask3,'barrier'] + co[3] * cms[mask3,'training'],
            cms[mask3,'event']) + coord_fixed() + geom_abline(slope=1, color="red") +
        labs(x=paste(co[1],"+", co[2],"barrier","+",co[3], "training"), y="event"))

if (0) {
  table(espt$wave[is.na(cms[,'barrier'])])
  mask <- espt$wave == "earlydata/ppool-20130219" #& is.na(cms[,'barrier'])
  
  espt[mask, c("wantLearn", "msAfraid", "msIdentity", "msFast", "msEffort", "msLife")]
}
@

A simple linear model to predict event from barrier and training
obtains $R^2 = \Sexpr{summary(fit1)[["r.squared"]]}$.

\includepdf[pages={3-}]{archive/short-201408.pdf}

\end{document}
