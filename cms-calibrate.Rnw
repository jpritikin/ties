\documentclass[12pt]{article}
\usepackage[margin=.5in]{geometry}
\usepackage{pdfpages}
\setlength{\parindent}{0cm}
\setlength{\parskip}{1ex}

<<echo=FALSE, results='hide', warning=FALSE, cache=FALSE>>=
#options(error = browser)
library(knitr)
#knit("cms-calibrate.Rnw", tangle=TRUE)  # to extract only the R chunks
opts_knit$set(error=TRUE)
opts_chunk$set(echo=FALSE, cache=FALSE)
loadlib <- function () {
library(rpf)
library(OpenMx)
library(ggplot2)
library(reshape2)
library(plyr)
library(grid)
library(gridExtra)
library(xtable)
}
suppressPackageStartupMessages(loadlib())
options(digits=2, scipen=1)
plot.width=3

assertColumnExist <- function(col) {
  missing <- col[is.na(match(col, colnames(espt)))]
  if (length(missing)) stop(paste("Columns missing:", omxQuotes(missing)))
}

itemMapText <- geom_text(size=4, position=position_jitter(h=.25))
@

\title{Calibration of item models for the Complete Mental Silence Disposition Scale}
\date{\today}
\author{Joshua N.~Pritikin\\ University of Virginia}

\begin{document}
\maketitle

\section{Data Sources}

The CMS calibration sample is composed of a number of different datasets.

<<results='asis'>>=
source('irtplot.R')
source("cms-score-lib.R")

load("espt.rda")
espt <- cms.testlets(espt)

src <- ddply(espt, ~wave, function(slice) c(types=length(unique(slice$instrument))))

if (any(src$types != 1)) {
  stop("There should be no more than 1 instrument version per wave.")
}

src <- ddply(espt, ~wave, function(slice) c(instrument=unique(slice$instrument), count=nrow(slice),
                                            start=min(slice$start), end=max(slice$end)))
src <- src[order(src$instrument, src$end, src$start),]
print(xtable(src), include.rownames=FALSE)
@

A large proportion of data is missing, but the maximum N=\Sexpr{sum(as.numeric(src$count))}.

\section{Barrier}

The \emph{barrier} factor is intended to non-judgmentally assess the participant's
self-reported inability to experience complete mental silence.
The items must make sense on a short time horizon and
should also be amenable to long-term barriers.

<<>>=
fitBarrer <- function(barrier.items) {
  assertColumnExist(barrier.items)
  
  ba.data <- espt[,barrier.items]
  
  spec <- lapply(barrier.items, function(nm) {
    lev <- length(levels(ba.data[[ nm ]]))
    rpf.grm(outcomes=lev, factors=3)
  })
  
  maxParam <- max(sapply(spec, rpf.numParam))
  factors <- c('barrier', 'emo', 'struct')
  ip.mat <- mxMatrix(name="ItemParam", nrow=maxParam, ncol=length(spec), free=FALSE,
                     dimnames=list(c(factors,
                                     paste('b', 4:maxParam, sep="")), barrier.items))
  ip.mat$values['barrier',] <- 1
  ip.mat$values['emo',intersect(c('wantLearn', "msAfraid", "msIdentity","msEmo"),barrier.items)] <- 1
  ip.mat$values['struct',intersect(c("msFast", "msFast1", "msEffort", "msLife"), barrier.items)] <- 1
  ip.mat$values[4:7,] <- mxSimplify2Array(lapply(spec, function(s) seq(1,.1,length.out = s$outcomes-1)))
  ip.mat$free[,] <- !is.na(ip.mat$values[,]) & ip.mat$values[,] != 0
  
  m.mat <- mxMatrix(name="mean", nrow=length(factors), ncol=1, values=0)
  rownames(m.mat) <- factors
  cov.mat <- mxMatrix("Symm", name="cov", nrow=3, ncol=3, values=diag(3),
                      dimnames=list(factors, factors))
  
  ba <- mxModel(model="barrier",
                m.mat, cov.mat, ip.mat,
                mxData(observed=ba.data, type="raw"),
                mxExpectationBA81(mean="mean", cov="cov", qwidth=5, qpoints=39,
                                  ItemSpec=spec, ItemParam="ItemParam", scores="full", naAction="pass"),
                mxFitFunctionML(),
                mxComputeSequence(steps=list(
                  mxComputeEM('expectation', 'scores', mxComputeNewtonRaphson()),
                  mxComputeOnce('fitfunction', 'information', "meat"),
                  mxComputeStandardError(),
                  mxComputeHessianQuality())
                ))
  got <- mxRun(ba, silent=TRUE)
  got
}

# "msDescarte" == worst S fit
# "wantLearn" poor discrimination, locally dependent with msEffort (duh) & msEmo
ba.est <- fitBarrer(c("msAfraid", "msIdentity", "msFast1", "msEffort", "msLife", "msEmo"))

interactive <- FALSE
if (interactive) {
  ba.est$output$conditionNumber
}
ba.grp <- list(spec=ba.est$expectation$ItemSpec,
              param=ba.est$ItemParam@values,
              mean=ba.est$mean@values,
              cov=ba.est$cov@values,
              scores=ba.est@expectation@output$scores,
              data=espt[,colnames(ba.est$ItemParam)], minItems=1L, free=ba.est$ItemParam$free)

mnf <- multinomialFit(ba.grp)
if (interactive) {
  ba.grp$param
  mnf
}

if (0) {
  mcReps <- 250
  stat <- rep(NA, mcReps)
  for (rx in 1:mcReps) {
    t1 <- ba.grp
    t1$data <- rpf.sample(grp=ba.grp)
    got <- multinomialFit(t1)
    stat[rx] <- got$statistic
  }
  log(sum(stat > mnf$statistic) / mcReps)
}
@ 

For a single factor model, the items were highly locally dependent.
Two subfactors were hypothesized: an emotional subfactor for
\Sexpr{names(which(ba.grp$param['emo',] !=0))}; and a structural subfactor for
\Sexpr{names(which(ba.grp$param['struct',] !=0))}.
A candidate bi-factor model was fit with -2LL=\Sexpr{ba.est$output$fit} and
condition number \Sexpr{ba.est$output$conditionNumber}.
The full-information multinomial fit test was conducted,
$G^2(\Sexpr{mnf$df})=\Sexpr{mnf$statistic}$.
Since the $\chi^2$ distribution is a poor approximation
for such a large table, a $p$-value of about .05
was obtained via Monte-Carlo simulation.

<<results='asis'>>=
got <- ChenThissen1997(ba.grp)
print(xtable(got$pval, paste("Log p-value of local dependence between item pairs.",
                             "Although statistically significant, all values are",
                             "negative, meaning that there is less observed correlation",
                             "among the residuals than expected.")))
@

<<results='asis'>>=
sfit <- SitemFit(ba.grp, omit = 1, qpoints=15, qwidth=5)
tbl <- t(sapply(sfit, function(r) c(n=r$n, df=r$df, stat=r$statistic, pval=r$pval)))
print(xtable(tbl, paste("Sum-score item-wise fit, omitting 1 item.",
                        "For msFast, \\emph{disagree somewhat} was collapsed",
                        "to \\emph{not sure} to improve fit.",
                        "There may be more room for improvement here.")))
@

<<fig.height=2>>=
map1 <- item.map(ba.grp, 1)
ggplot(map1, aes(x=score, y=item, label=outcome)) + itemMapText
@

<<fig.height=3>>=
pl <- lapply(colnames(ba.grp$param), function(item) {
  SSplot(sfit, item)
})
for (px in 1:length(pl)) {
  print(pl[[px]])
}
print(plot.info(ba.grp, width=5, show.total=FALSE, basis=c(1,0,0)))
@

\section{Training}

The \emph{training} factor is intended to assess the self-reported degree
of preparation and expertise a participant has with complete mental silence.
The items probe ability to cause oneself to experience mental silence
and ability to work with others.
To assess experience with others,
items probe both belief in oneself to work with others and
quantitatively how much one has worked with others.

<<>>=
fitTraining <- function(training.items, minItems) {
  assertColumnExist(training.items)
  
  spec <- mkspec(espt, training.items)
  numItems <- length(training.items)
  maxParam <- max(sapply(spec, rpf.numParam))
  
  ip.mat <- mxMatrix(name="ItemParam", nrow=maxParam, ncol=numItems, free=FALSE,
                     dimnames=list(c('training', paste('p',2:maxParam,sep="")), training.items))
  
  ip.mat <- set.nominal.rank(spec, ip.mat, 'msNotion', .51, 1)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'msYearn', .51, 1)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'msEnv', .51, 1)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'yearnEnv', .27, .27)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'msAllow', .51, 1)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'msCause', .51, 1)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'allowCause', .27, .27)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'trainSkill', .2, .2)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'trainNum', .1, .15)
  
  tr.data <- espt[,training.items]
  
  m.mat <- mxMatrix(name="mean", nrow=1, ncol=1, values=0)
  rownames(m.mat) <- "training"
  cov.mat <- mxMatrix("Symm", name="cov", nrow=1, ncol=1, values=diag(1),
                      dimnames=list("training", "training"))
  
  train <- mxModel(model="training",
                   m.mat, cov.mat, ip.mat,
                   mxData(observed=tr.data, type="raw"),
                   mxExpectationBA81(mean="mean", cov="cov",
                                     ItemSpec=spec, ItemParam="ItemParam", scores="full",
                                     naAction="pass", minItemsPerScore=minItems),
                   mxFitFunctionML(),
                   mxComputeSequence(steps=list(
                     mxComputeEM('expectation', 'scores', mxComputeNewtonRaphson()),
                     mxComputeOnce('fitfunction', 'information', "meat"),
                     mxComputeStandardError(),
                     mxComputeHessianQuality())
                   ))
  mxRun(train, silent=TRUE)
}

# not specific enough: "msAny", "msEvery"
tr.est <- fitTraining(c("yearnEnv", "allowCause", "trainSkill", "trainNum"), 2L)
tr.grp <- list(spec=tr.est$expectation$ItemSpec,
            param=tr.est$ItemParam@values,
            mean=tr.est$mean@values,
            cov=tr.est$cov@values,
            scores=tr.est@expectation@output$scores,
            data=espt[,colnames(tr.est$ItemParam)], minItems=2L)
@

Calibration of the training factor is hindered by the late addition
of the trainNum item. A possible model obtains -2LL=\Sexpr{tr.est$output$fit}
with condition number \Sexpr{tr.est$output$conditionNumber}.

<<results='asis'>>=
got <- chen.thissen.1997(tr.grp)
print(xtable(got$pval, "Log p-value of local dependence between item pairs."))
@ 

<<fig.height=2>>=
map1 <- item.map(tr.grp, 1)
ggplot(map1, aes(x=score, y=item, label=outcome)) + itemMapText
@

<<fig.height=3>>=
pl <- lapply(colnames(tr.grp$param), function(item) {
  rpf.plot(tr.grp, item, width=plot.width, data.bins=12, basis=c(1), factor=1)
})
for (px in 1:length(pl)) {
  print(pl[[px]])
}
print(plot.info(tr.grp, width=4, show.total=FALSE))
@

\section{Event}

The \emph{event} factor is intended to assess the self-reported
intensity of experiencing complete mental silence.

<<>>=
fitEvent <- function(event.items, minItems) {
  assertColumnExist(event.items)
  
  spec <- mkspec(espt, event.items)
  numItems <- length(event.items)
  maxParam <- max(sapply(spec, rpf.numParam))
  
  ip.mat <- mxMatrix(name="ItemParam", nrow=maxParam, ncol=numItems, free=FALSE,
                     dimnames=list(c("event", paste("p",2:maxParam,sep="")), event.items))
  
  ip.mat <- set.nominal.rank(spec, ip.mat, 'msAny', .51, 1)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'msEvery', .51, 1)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'freqCause', .51, 1)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'successCat', .35, .5)
  ip.mat <- set.nominal.rank(spec, ip.mat, 'maxDuration', .51, 1)
  
  m.mat <- mxMatrix(name="mean", nrow=1, ncol=1, values=0)
  rownames(m.mat) <- "event"
  cov.mat <- mxMatrix("Symm", name="cov", nrow=1, ncol=1, values=diag(1),
                      dimnames=list("event", "event"))

  ev.data <- espt[,event.items]
  
  ev <- mxModel(model="event",
                m.mat, cov.mat, ip.mat,
                mxData(observed=ev.data, type="raw"),
                mxExpectationBA81(mean="mean", cov="cov", naAction="pass", minItemsPerScore=minItems,
                                  ItemSpec=spec, ItemParam="ItemParam", scores="full"),
                mxFitFunctionML(),
                mxComputeSequence(steps=list(
                  mxComputeEM('expectation', 'scores', mxComputeNewtonRaphson()),
                  mxComputeOnce('fitfunction', 'information', "meat"),
                  mxComputeStandardError(),
                  mxComputeHessianQuality())
                ))
  mxRun(ev, silent=TRUE)
}

ev.est <- fitEvent(c("freqCause", "successCat", "maxDuration"), 2L)

ev.grp <- list(spec=ev.est$expectation$ItemSpec,
            param=ev.est$ItemParam@values,
            mean=ev.est$mean@values,
            cov=ev.est$cov@values,
            scores=ev.est@expectation@output$scores,
            data=espt[,colnames(ev.est$ItemParam)], minItems=2L)
@ 

A possible model has -2LL=\Sexpr{ev.est$output$fit} and
condition number \Sexpr{ev.est$output$conditionNumber}.

<<results='asis'>>=
got <- chen.thissen.1997(ev.grp)
print(xtable(got$pval, "Log p-value of local dependence between item pairs."))
@ 

<<fig.height=2>>=
map1 <- item.map(ev.grp, 1)
ggplot(map1, aes(x=score, y=item, label=outcome)) + itemMapText
@

<<fig.height=3>>=
pl <- lapply(colnames(ev.grp$param), function(item) {
  rpf.plot(ev.grp, item, width=plot.width, data.bins=12, basis=c(1), factor=1)
})
for (px in 1:length(pl)) {
  print(pl[[px]])
}
print(plot.info(ev.grp, width=4, show.total=FALSE))
@ 

<<>>=
save(ba.grp, tr.grp, ev.grp, file="cms-fit.rda")

if (0) {
  library(ggplot2)
  library(stringr)
  scores <- m2.est@expectation@scores.out
  espt$interest <- scores[,1]
  espt$experience <- scores[,2]
  ggplot(subset(espt, !is.na(str_match(espt$wave, "^germano"))),
         aes(interest, experience, color=wave, group=email)) +
    geom_point(size=1) + geom_line(size=.1) + coord_fixed()
}

#items <- t(m2$ItemParam@values)
#rownames(items) <- item.names
#espt[mask, "score"] <- m2@expectation@scores.out[,1]
#espt[mask, "se"] <- m2@expectation@scores.out[,2]

if (0) {
  sc <- m2.est@expectation@scores.out
  for (l in 1:3) {
    mask <- espt$durationCharacter==levels(espt$durationCharacter)[l]
    mask <- !is.na(mask) & mask
    print(paste(l, mean(sc[mask,1]), mean(sc[mask,2])))
  }
}
@

\section{Cross-sectional Relationship}

<<results='asis'>>=
source("cms-score.R")
cms <- cms.score(espt)
miss <- apply(cms, 2, function(c) sum(is.na(c))) / nrow(cms)
miss <- t(100 * miss)
rownames(miss) <- "% missing"
print(xtable(miss, "Percentage of scores missing."))
@ 

<<results='asis'>>=
fl <- rbind(apply(cms, 2, function(c) sum(c==min(c, na.rm=TRUE), na.rm=TRUE)),
            apply(cms, 2, function(c) sum(c==max(c, na.rm=TRUE), na.rm=TRUE)))
fl <- fl * 100 / nrow(cms)
rownames(fl) <- c("floor", "ceiling")
print(xtable(fl, "Percentage of scores at floor and ceiling."))
@ 

<<results='asis'>>=
ctbl <- cor(cms, use="pairwise.complete.obs")
ctbl[upper.tri(ctbl, diag=TRUE)] <- NA
print(xtable(ctbl, "Correlation matrix of factor scores."))
@ 

<<fig.height=3>>=
mask1 <- !is.na(cms[,'barrier']) & !is.na(cms[,'event'])
mask2 <- !is.na(cms[,'training']) & !is.na(cms[,'event'])
grid.arrange(qplot(cms[mask1,'barrier'],  cms[mask1,'event']) + coord_fixed() +
                     labs(x="barrier", y="event") + geom_abline(slope=-1, color="red"),
                   qplot(cms[mask2,'training'], cms[mask2,'event']) + coord_fixed() +
                     labs(x="training", y="event") + geom_abline(slope=1, color="red"), ncol=2)

fit1 <- lm(event ~ ., data=as.data.frame(cms))
#  plot(fit1)

co <- round(coef(fit1),2)
mask3 <- apply(cms, 1, function (r) all(!is.na(r)))
print(qplot(co[1] + co[2] * cms[mask3,'barrier'] + co[3] * cms[mask3,'training'],
            cms[mask3,'event']) + coord_fixed() + geom_abline(slope=1, color="red") +
        labs(x=paste(co[1],"+", co[2],"barrier","+",co[3], "training"), y="event"))

if (0) {
  table(espt$wave[is.na(cms[,'barrier'])])
  mask <- espt$wave == "earlydata/ppool-20130219" #& is.na(cms[,'barrier'])
  
  espt[mask, c("wantLearn", "msAfraid", "msIdentity", "msFast", "msEffort", "msLife")]
}
@

A simple linear model to predict event from barrier and training
obtains $R^2 = \Sexpr{summary(fit1)[["r.squared"]]}$.

\includepdf[pages={3-}]{archive/short-20140116.pdf}

\end{document}
